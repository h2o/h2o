.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "OBJ_nid2obj 3"
.TH OBJ_nid2obj 3 "2017-01-09" "LibreSSL " "LibreSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid,
OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, OBJ_cleanup
\&\- ASN1 object utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/objects.h>
\&
\& ASN1_OBJECT * OBJ_nid2obj(int n);
\& const char *  OBJ_nid2ln(int n);
\& const char *  OBJ_nid2sn(int n);
\&
\& int OBJ_obj2nid(const ASN1_OBJECT *o);
\& int OBJ_ln2nid(const char *ln);
\& int OBJ_sn2nid(const char *sn);
\&
\& int OBJ_txt2nid(const char *s);
\&
\& ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);
\& int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);
\&
\& int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);
\& ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);
\&
\& int OBJ_create(const char *oid,const char *sn,const char *ln);
\& void OBJ_cleanup(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1ASN1\s0 object utility functions process \s-1ASN1_OBJECT\s0 structures which are
a representation of the \s-1ASN1 OBJECT IDENTIFIER \s0(\s-1OID\s0) type.
.PP
\&\fIOBJ_nid2obj()\fR, \fIOBJ_nid2ln()\fR and \fIOBJ_nid2sn()\fR convert the \s-1NID \s0\fBn\fR to
an \s-1ASN1_OBJECT\s0 structure, its long name and its short name respectively,
or \fB\s-1NULL\s0\fR is an error occurred.
.PP
\&\fIOBJ_obj2nid()\fR, \fIOBJ_ln2nid()\fR, \fIOBJ_sn2nid()\fR return the corresponding \s-1NID\s0
for the object \fBo\fR, the long name <ln> or the short name <sn> respectively
or NID_undef if an error occurred.
.PP
\&\fIOBJ_txt2nid()\fR returns \s-1NID\s0 corresponding to text string <s>. \fBs\fR can be
a long name, a short name or the numerical representation of an object.
.PP
\&\fIOBJ_txt2obj()\fR converts the text string \fBs\fR into an \s-1ASN1_OBJECT\s0 structure.
If \fBno_name\fR is 0 then long names and short names will be interpreted
as well as numerical forms. If \fBno_name\fR is 1 only the numerical form
is acceptable.
.PP
\&\fIOBJ_obj2txt()\fR converts the \fB\s-1ASN1_OBJECT\s0\fR \fBa\fR into a textual representation.
The representation is written as a null terminated string to \fBbuf\fR
at most \fBbuf_len\fR bytes are written, truncating the result if necessary.
The total amount of space required is returned. If \fBno_name\fR is 0 then
if the object has a long or short name then that will be used, otherwise
the numerical form will be used. If \fBno_name\fR is 1 then the numerical
form will always be used.
.PP
\&\fIOBJ_cmp()\fR compares \fBa\fR to \fBb\fR. If the two are identical 0 is returned.
.PP
\&\fIOBJ_dup()\fR returns a copy of \fBo\fR.
.PP
\&\fIOBJ_create()\fR adds a new object to the internal table. \fBoid\fR is the
numerical form of the object, \fBsn\fR the short name and \fBln\fR the
long name. A new \s-1NID\s0 is returned for the created object.
.PP
\&\fIOBJ_cleanup()\fR cleans up OpenSSLs internal object table: this should
be called before an application exits if any new objects were added
using \fIOBJ_create()\fR.
.SH "NOTES"
.IX Header "NOTES"
Objects in OpenSSL can have a short name, a long name and a numerical
identifier (\s-1NID\s0) associated with them. A standard set of objects is
represented in an internal table. The appropriate values are defined
in the header file \fBobjects.h\fR.
.PP
For example the \s-1OID\s0 for commonName has the following definitions:
.PP
.Vb 3
\& #define SN_commonName                   "CN"
\& #define LN_commonName                   "commonName"
\& #define NID_commonName                  13
.Ve
.PP
New objects can be added by calling \fIOBJ_create()\fR.
.PP
Table objects have certain advantages over other objects: for example
their NIDs can be used in a C language switch statement. They are
also static constant structures which are shared: that is there
is only a single constant structure for each table object.
.PP
Objects which are not in the table have the \s-1NID\s0 value NID_undef.
.PP
Objects do not need to be in the internal tables to be processed,
the functions \fIOBJ_txt2obj()\fR and \fIOBJ_obj2txt()\fR can process the numerical
form of an \s-1OID.\s0
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Create an object for \fBcommonName\fR:
.PP
.Vb 2
\& ASN1_OBJECT *o;
\& o = OBJ_nid2obj(NID_commonName);
.Ve
.PP
Check if an object is \fBcommonName\fR
.PP
.Vb 2
\& if (OBJ_obj2nid(obj) == NID_commonName)
\&        /* Do something */
.Ve
.PP
Create a new \s-1NID\s0 and initialize an object from it:
.PP
.Vb 3
\& int new_nid;
\& ASN1_OBJECT *obj;
\& new_nid = OBJ_create("1.2.3.4", "NewOID", "New Object Identifier");
\&
\& obj = OBJ_nid2obj(new_nid);
.Ve
.PP
Create a new object directly:
.PP
.Vb 1
\& obj = OBJ_txt2obj("1.2.3.4", 1);
.Ve
.SH "BUGS"
.IX Header "BUGS"
\&\fIOBJ_obj2txt()\fR is awkward and messy to use: it doesn't follow the
convention of other OpenSSL functions where the buffer can be set
to \fB\s-1NULL\s0\fR to determine the amount of data that should be written.
Instead \fBbuf\fR must point to a valid buffer and \fBbuf_len\fR should
be set to a positive value. A buffer length of 80 should be more
than enough to handle any \s-1OID\s0 encountered in practice.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIOBJ_nid2obj()\fR returns an \fB\s-1ASN1_OBJECT\s0\fR structure or \fB\s-1NULL\s0\fR is an
error occurred.
.PP
\&\fIOBJ_nid2ln()\fR and \fIOBJ_nid2sn()\fR returns a valid string or \fB\s-1NULL\s0\fR
on error.
.PP
\&\fIOBJ_obj2nid()\fR, \fIOBJ_ln2nid()\fR, \fIOBJ_sn2nid()\fR and \fIOBJ_txt2nid()\fR return
a \s-1NID\s0 or \fBNID_undef\fR on error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3)
