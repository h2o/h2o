.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "X509_STORE_CTX_new 3"
.TH X509_STORE_CTX_new 3 "2017-01-09" "LibreSSL " "LibreSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_STORE_CTX_new, X509_STORE_CTX_cleanup, X509_STORE_CTX_free,
X509_STORE_CTX_init, X509_STORE_CTX_trusted_stack, X509_STORE_CTX_set_cert,
X509_STORE_CTX_set_chain, X509_STORE_CTX_set0_crls, X509_STORE_CTX_get0_param,
X509_STORE_CTX_set0_param, X509_STORE_CTX_set_default \- X509_STORE_CTX
initialisation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509_vfy.h>
\&
\& X509_STORE_CTX *X509_STORE_CTX_new(void);
\& void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);
\& void X509_STORE_CTX_free(X509_STORE_CTX *ctx);
\&
\& int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
\&                         X509 *x509, STACK_OF(X509) *chain);
\&
\& void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);
\&
\& void   X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx,X509 *x);
\& void   X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx,STACK_OF(X509) *sk);
\& void   X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk);
\&
\& X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);
\& void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);
\& int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions initialise an \fBX509_STORE_CTX\fR structure for subsequent use
by \fIX509_verify_cert()\fR.
.PP
\&\fIX509_STORE_CTX_new()\fR returns a newly initialised \fBX509_STORE_CTX\fR structure.
.PP
\&\fIX509_STORE_CTX_cleanup()\fR internally cleans up an \fBX509_STORE_CTX\fR structure.
The context can then be reused with an new call to \fIX509_STORE_CTX_init()\fR.
.PP
\&\fIX509_STORE_CTX_free()\fR completely frees up \fBctx\fR. After this call \fBctx\fR
is no longer valid.
.PP
\&\fIX509_STORE_CTX_init()\fR sets up \fBctx\fR for a subsequent verification operation.
The trusted certificate store is set to \fBstore\fR, the end entity certificate
to be verified is set to \fBx509\fR and a set of additional certificates (which
will be untrusted but may be used to build the chain) in \fBchain\fR. Any or
all of the \fBstore\fR, \fBx509\fR and \fBchain\fR parameters can be \fB\s-1NULL\s0\fR.
.PP
\&\fIX509_STORE_CTX_trusted_stack()\fR sets the set of trusted certificates of \fBctx\fR
to \fBsk\fR. This is an alternative way of specifying trusted certificates
instead of using an \fBX509_STORE\fR.
.PP
\&\fIX509_STORE_CTX_set_cert()\fR sets the certificate to be verified in \fBctx\fR to
\&\fBx\fR.
.PP
\&\fIX509_STORE_CTX_set_chain()\fR sets the additional certificate chain used by \fBctx\fR
to \fBsk\fR.
.PP
\&\fIX509_STORE_CTX_set0_crls()\fR sets a set of CRLs to use to aid certificate
verification to \fBsk\fR. These CRLs will only be used if \s-1CRL\s0 verification is
enabled in the associated \fBX509_VERIFY_PARAM\fR structure. This might be
used where additional \*(L"useful\*(R" CRLs are supplied as part of a protocol,
for example in a PKCS#7 structure.
.PP
X509_VERIFY_PARAM *\fIX509_STORE_CTX_get0_param()\fR retrieves an internal pointer
to the verification parameters associated with \fBctx\fR.
.PP
\&\fIX509_STORE_CTX_set0_param()\fR sets the internal verification parameter pointer
to \fBparam\fR. After this call \fBparam\fR should not be used.
.PP
\&\fIX509_STORE_CTX_set_default()\fR looks up and sets the default verification
method to \fBname\fR. This uses the function \fIX509_VERIFY_PARAM_lookup()\fR to
find an appropriate set of parameters from \fBname\fR.
.SH "NOTES"
.IX Header "NOTES"
The certificates and CRLs in a store are used internally and should \fBnot\fR
be freed up until after the associated \fBX509_STORE_CTX\fR is freed. Legacy
applications might implicitly use an \fBX509_STORE_CTX\fR like this:
.PP
.Vb 2
\&  X509_STORE_CTX ctx;
\&  X509_STORE_CTX_init(&ctx, store, cert, chain);
.Ve
.PP
this is \fBnot\fR recommended in new applications they should instead do:
.PP
.Vb 5
\&  X509_STORE_CTX *ctx;
\&  ctx = X509_STORE_CTX_new();
\&  if (ctx == NULL)
\&        /* Bad error */
\&  X509_STORE_CTX_init(ctx, store, cert, chain);
.Ve
.SH "BUGS"
.IX Header "BUGS"
The certificates and CRLs in a context are used internally and should \fBnot\fR
be freed up until after the associated \fBX509_STORE_CTX\fR is freed. Copies
should be made or reference counts increased instead.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIX509_STORE_CTX_new()\fR returns an newly allocates context or \fB\s-1NULL\s0\fR is an
error occurred.
.PP
\&\fIX509_STORE_CTX_init()\fR returns 1 for success or 0 if an error occurred.
.PP
\&\fIX509_STORE_CTX_get0_param()\fR returns a pointer to an \fBX509_VERIFY_PARAM\fR
structure or \fB\s-1NULL\s0\fR if an error occurred.
.PP
\&\fIX509_STORE_CTX_cleanup()\fR, \fIX509_STORE_CTX_free()\fR, \fIX509_STORE_CTX_trusted_stack()\fR,
\&\fIX509_STORE_CTX_set_cert()\fR, \fIX509_STORE_CTX_set_chain()\fR,
\&\fIX509_STORE_CTX_set0_crls()\fR and \fIX509_STORE_CTX_set0_param()\fR do not return
values.
.PP
\&\fIX509_STORE_CTX_set_default()\fR returns 1 for success or 0 if an error occurred.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIX509_verify_cert\fR\|(3)
\&\fIX509_VERIFY_PARAM_set_flags\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIX509_STORE_CTX_set0_crls()\fR was first added to OpenSSL 1.0.0
